<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="Palikka API documentation for version 0.3.1">
  <title>Palikka - v0.3.1 Documentation</title>
  <link href="static/css/normalize.css" rel="stylesheet">
  <link href="static/css/font-awesome.css" rel="stylesheet">
  <link href="static/css/base.css" rel="stylesheet">
  <link href="static/css/components.css" rel="stylesheet">
  <link href="static/css/app.css" rel="stylesheet">
  <script type="text/javascript">
    WebFontConfig = {
      google: {
        families: ["Droid+Sans+Mono::latin", "Roboto:400,300,300italic,400italic,500,500italic,700,700italic:latin", ]
      }
    };
    (function() {
      var wf = document.createElement('script');
      wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
        '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
      wf.type = 'text/javascript';
      wf.async = 'true';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(wf, s);
    })();
  </script>
  <script src="static/js/libs/palikka.js"></script>
  <script src="static/js/libs/jquery.js"></script>
  <script src="static/js/libs/velocity.js"></script>
  <script src="static/js/docs.js"></script>
  <script>
    palikka
      .define('jQuery', function() {
        return window[this.id];
      })
      .define('jQuery.velocity', ['jQuery'], function($) {
        return $;
      })
      .define('docReady', ['jQuery'], function($) {
        return palikka.defer(function(resolve) {
          $(resolve);
        });
      })
      .define('winReady', function() {
        return palikka.defer(function(resolve) {
          window.onload = resolve;
        });
      });
  </script>
</head>

<body>

  <div class="header">
    <div class="header-logo"><a href="http://niklasramo.github.io/palikka/">Palikka</a></div>
    <div class="header-title">v0.3.1 Documentation</div>
    <div class="header-links">
      <a href="https://raw.githubusercontent.com/niklasramo/palikka/v0.3.1/palikka.js"><i class="fa fa-download"></i><span>Download</span></a>
      <a href="https://github.com/niklasramo/palikka"><i class="fa fa-github"></i><span>GitHub</span></a>
    </div>
  </div>

  <div class="content-root">

    <div class="menubar">
      <div class="menu">
        <a href="#introduction" class="level-1">Introduction</a>
        <a href="#getting-started" class="level-1">Getting started</a>
        <a href="#modules" class="level-1">Modules</a>
        <a href="#define" class="level-2">.define()</a>
        <a href="#require" class="level-2">.require()</a>
        <a href="#events" class="level-1">Events</a>
        <a href="#eventizer" class="level-2">.Eventizer()</a>
        <a href="#eventizerprototypeon" class="level-2">.Eventizer.prototype.on()</a>
        <a href="#eventizerprototypeone" class="level-2">.Eventizer.prototype.one()</a>
        <a href="#eventizerprototypeoff" class="level-2">.Eventizer.prototype.off()</a>
        <a href="#eventizerprototypeemit" class="level-2">.Eventizer.prototype.emit()</a>
        <a href="#eventizerprototypeemitasync" class="level-2">.Eventizer.prototype.emitAsync()</a>
        <a href="#eventize" class="level-2">.eventize()</a>
        <a href="#deferreds" class="level-1">Deferreds</a>
        <a href="#deferred" class="level-2">.Deferred()</a>
        <a href="#deferredprototypestate" class="level-2">.Deferred.prototype.state()</a>
        <a href="#deferredprototyperesult" class="level-2">.Deferred.prototype.result()</a>
        <a href="#deferredprototyperesolve" class="level-2">.Deferred.prototype.resolve()</a>
        <a href="#deferredprototypereject" class="level-2">.Deferred.prototype.reject()</a>
        <a href="#deferredprototypeonfulfilled" class="level-2">.Deferred.prototype.onFulfilled()</a>
        <a href="#deferredprototypeonrejected" class="level-2">.Deferred.prototype.onRejected()</a>
        <a href="#deferredprototypeonsettled" class="level-2">.Deferred.prototype.onSettled()</a>
        <a href="#deferredprototypethen" class="level-2">.Deferred.prototype.then()</a>
        <a href="#deferredprototypeand" class="level-2">.Deferred.prototype.and()</a>
        <a href="#defer" class="level-2">.defer()</a>
        <a href="#when" class="level-2">.when()</a>
        <a href="#examples" class="level-1">Examples</a>
        <a href="#importing-third-party-libraries-as-modules" class="level-2">Importing third party libraries as modules</a>
      </div>
    </div>

    <!-- https://stackedit.io/ and http://jsbeautifier.org/ -->
    <div class="content">

      <h2 id="introduction">Introduction</h2>

      <p>
        <a href="https://travis-ci.org/niklasramo/palikka"><img src="https://travis-ci.org/niklasramo/palikka.svg?branch=v0.3.1" alt="Build Status" title=""></a>
        <a href="https://coveralls.io/r/niklasramo/palikka?branch=v0.3.1"><img src="https://coveralls.io/repos/niklasramo/palikka/badge.svg?branch=v0.3.1" alt="Coverage Status" title=""></a>
      </p>

      <p>A compact and well-tested JavaScript module/event/promise system that works in the browser (all the way down to IE7) and Node.js. So, why bundle three different libraries together? Both a module and a promise system require an event system to work so it makes sense to optimize their synergies internally in order to keep the code DRY and performant. The primary goal of this project is to provide a solid <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> based module system.</p>

      <ul>
        <li>Lightweight, around 5.8kb minified and 2.3kb minified and gzipped.</li>
        <li>Works both in the browser (IE7+) and in Node.js.</li>
        <li>Well documented codebase.</li>
        <li>Comprehensive unit tests.</li>
        <li>No dependencies.</li>
      </ul>

      <h2 id="getting-started">Getting started</h2>

      <p>Include <a href="https://raw.githubusercontent.com/niklasramo/palikka/v0.3.1/palikka.js">palikka.js</a> somewhere on your site (before any code that requires Palikka).</p>

      <pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// Define module "foo" which requires module "bar".</span>
palikka.define(<span class="hljs-string">'foo'</span>, [<span class="hljs-string">'bar'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(bar)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'foo'</span>;
});

<span class="hljs-comment">// Define module "bar".</span>
palikka.define(<span class="hljs-string">'bar'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>

  <span class="hljs-comment">// Use promises (deferred) to delay the initiation.</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> palikka.Deferred(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(resolve, reject)</span> {</span>
    window.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      resolve(<span class="hljs-string">'bar'</span>);
    }, <span class="hljs-number">1000</span>);
  });

});

<span class="hljs-comment">// Require modules "foo" and "bar".</span>
palikka.require([<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(foo, bar)</span> {</span>
  console.log(foo + bar); <span class="hljs-comment">// "foobar"</span>
});</code></pre>

      <h2 id="modules">Modules</h2>

      <p>The Module system API is derived from <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD spec</a> and <a href="http://requirejs.org/docs/api.html">RequireJS API</a>. However, Palikka does not do any file loading so it is not AMD compatible. The purpose of the module system is to make it possible to split the codebase into separate self-functioning units which know their dependencies. Palikka then makes sure that the dependencies are loaded before the module is defined. In essence Palikka’s modules are named <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a>. The module system is tightly bound to Palikka’s own promise system, <a href="#deferreds">Deferreds</a>.</p>

      <p>The <a href="#define"><code>.define()</code></a> and <a href="#require"><code>.require()</code></a> methods are asynchronous by default, meaning that their factory/callback functions are called in the beginning of the next <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">event loop</a>, or more familiarly “next tick”. Under the hood a module instance is basically just a lightweight wrapper around <a href="#deferred"><code>.Deferred()</code></a> instance, which is asynchronous by default as per <a href="https://promisesaplus.com/">Promises/A+</a> specification. However, this behaviour can be switched off forcing <a href="#define"><code>.define()</code></a> and <a href="#require"><code>.require()</code></a> to execute their factory/callback functions synchronously: <code>palikka._config.asyncModules = false</code>.</p>

      <h3 id="define">.define()</h3>

      <p>Define a module.</p>

      <p><strong>Syntax</strong></p>

      <p><code>palikka.define( ids [, dependencies] , factory )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>ids</strong> &nbsp;—&nbsp; <em>array / string</em>
          <br>
          <ul>
            <li>Module id(s). Each module must have a unique id.</li>
          </ul>
        </li>
        <li><strong>dependencies</strong> &nbsp;—&nbsp; <em>array / string</em>
          <br>
          <ul>
            <li>Optional. Define multiple dependencies as an array of module ids and a single dependency as a string.</li>
          </ul>
        </li>
        <li><strong>factory</strong> &nbsp;—&nbsp; <em>function / object</em>
          <br>
          <ul>
            <li>this.id &nbsp;—&nbsp; <em>string</em></li>
            <li>this.dependencies &nbsp;—&nbsp; <em>object</em></li>
            <li>If the factory is a plain object it is directly assigned as the module’s value. If the factory is a function it is executed once after all dependencies have loaded and it’s return value will be assigned as the module’s value. If the return value is a deferred instance the module will be initiated when the deferred is resolved with the deferred’s value assigned as the module’s value. If the deferred is rejected the module will not be defined.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>object</em></p>

      <p>Returns palikka object, which means that you can chain <code>.define()</code> and <code>.require()</code> methods.</p>

      <p><strong>Usage</strong></p>

      <pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// Define a single module.</span>
palikka.define(<span class="hljs-string">'foo'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'foo'</span>;
});

<span class="hljs-comment">// Define a plain object as module.</span>
palikka.define(<span class="hljs-string">'bar'</span>, {bar: <span class="hljs-string">'bar'</span>});

<span class="hljs-comment">// Define a module with dependencies.</span>
palikka.define(<span class="hljs-string">'foobar'</span>, [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(foo, bar)</span> {</span>
  <span class="hljs-keyword">return</span> foo + bar.bar;
});

<span class="hljs-comment">// Define a module using delayed initiation.</span>
palikka.define(<span class="hljs-string">'delayed'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> palikka.Deferred(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(resolve)</span> {</span>
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      resolve(<span class="hljs-string">'I am delayed...'</span>);
    }, <span class="hljs-number">2000</span>);
  });
});

<span class="hljs-comment">// Define multiple modules at once.</span>
<span class="hljs-comment">// Handy for importing third party libraries.</span>
<span class="hljs-keyword">var</span> obj = {a: <span class="hljs-string">'a'</span>, b: <span class="hljs-string">'b'</span>};
palikka.define([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> obj[<span class="hljs-keyword">this</span>.id];
});</code></pre>

      <h3 id="require">.require()</h3>

      <p>Require modules (dependencies) and execute a function when they are loaded.</p>

      <p><strong>Syntax</strong></p>

      <p><code>palikka.require( dependencies, callback )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>dependencies</strong> &nbsp;—&nbsp; <em>array / string</em>
          <br>
          <ul>
            <li>Optional. Define multiple dependencies as an array of module ids and a single dependency as a string.</li>
          </ul>
        </li>
        <li><strong>callback</strong> &nbsp;—&nbsp; <em>function</em>
          <br>
          <ul>
            <li>The callback function that will be executed after all dependencies have loaded. Receives the required dependency modules as function arguments in the same order they were required.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>object</em></p>

      <p>Returns palikka object, which means that you can chain <code>.define()</code> and <code>.require()</code> methods.</p>

      <p><strong>Usage</strong></p>

      <pre class="prettyprint"><code class="language-javascript hljs ">palikka
.define(<span class="hljs-string">'foo'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'foo'</span>;
})
.define(<span class="hljs-string">'bar'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'bar'</span>;
})
.require([<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(foo, bar)</span> {</span>
  alert(foo + bar); <span class="hljs-comment">// "foobar"</span>
});</code></pre>

      <h2 id="events">Events</h2>

      <p>A very straightforward event system implementation with the ability to optionally emit events asynchronously.</p>

      <h3 id="eventizer">.Eventizer()</h3>

      <p>A constructor function that builds a fully functional “event hub” instance. All the event listeners are stored in a protected “listeners” object accesible via <code>instance._listeners</code>. However, it is not recommended to manipulate the object directly.</p>

      <p><strong>Syntax</strong></p>

      <p><code>palikka.Eventizer( [listeners] )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>listeners</strong> &nbsp;—&nbsp; <em>object</em>
          <br>
          <ul>
            <li>Optional. Defaults to <code>{}</code>. Provide an object where all the event listeners will be stored.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Usage</strong></p>

      <pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> eventizer = <span class="hljs-keyword">new</span> palikka.Eventizer();

eventizer
<span class="hljs-comment">// Bind a "test" event listener.</span>
.on(<span class="hljs-string">'test'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(ev, a, b)</span> {</span>

    console.log(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// eventizer</span>
    console.log(ev.id); <span class="hljs-comment">// a unique id (number), which can be used to unbind this specific callback</span>
    console.log(ev.type); <span class="hljs-comment">// "test"</span>
    console.log(ev.fn); <span class="hljs-comment">// callback function</span>
    console.log(a); <span class="hljs-comment">// "a"</span>
    console.log(b); <span class="hljs-comment">// "b"</span>

    <span class="hljs-comment">// You can unbind the event listener after first execution.</span>
    foo.off(ev.type, ev.fn);

})
<span class="hljs-comment">// Emit "test" event with some arguments,</span>
<span class="hljs-comment">// note that on/off/emit methods are chainable.</span>
.emit(<span class="hljs-string">'test'</span>, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);</code></pre>

      <h3 id="eventizerprototypeon">.Eventizer.prototype.on()</h3>

      <p>Bind a custom event listener to an Eventizer instance. The callback argument receives an event data object as it’s first argument.</p>

      <p><strong>Syntax</strong></p>

      <p><code>e.on( type, callback )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>type</strong> &nbsp;—&nbsp; <em>string</em>
          <br>
          <ul>
            <li>The type of the event.</li>
          </ul>
        </li>
        <li><strong>callback</strong> &nbsp;—&nbsp; <em>function</em>
          <br>
          <ul>
            <li>A callback function that will be executed, when this type of event is emitted.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Eventizer</em></p>

      <p>Returns the instance that called the method.</p>

      <h3 id="eventizerprototypeone">.Eventizer.prototype.one()</h3>

      <p>Same as <a href="#eventizerprototypeon">.Eventizer.prototype.on()</a> with the exeception that the callback function will be only executed once after which the event is automatically unbound.</p>

      <p><strong>Syntax</strong></p>

      <p><code>e.one( type, callback )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>type</strong> &nbsp;—&nbsp; <em>string</em>
          <br>
          <ul>
            <li>The type of the event.</li>
          </ul>
        </li>
        <li><strong>callback</strong> &nbsp;—&nbsp; <em>function</em>
          <br>
          <ul>
            <li>A callback function that will be executed, when this type of event is emitted.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Eventizer</em></p>

      <p>Returns the instance that called the method.</p>

      <h3 id="eventizerprototypeoff">.Eventizer.prototype.off()</h3>

      <p>Unbind event listener(s) from an Eventizer instance.</p>

      <p><strong>Syntax</strong></p>

      <p><code>e.off( type [, target] )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>type</strong> &nbsp;—&nbsp; <em>string</em>
          <br>
          <ul>
            <li>The type of the event.</li>
          </ul>
        </li>
        <li><strong>target</strong> &nbsp;—&nbsp; <em>function / number</em>
          <br>
          <ul>
            <li>Optional. If not provided all listeners for the specified type will be removed. If a function is provided, all listeners which match the function will be removed. If an id (number) is provided only that specific listener will be removed which matches the id.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Eventizer</em></p>

      <p>Returns the instance that called the method.</p>

      <h3 id="eventizerprototypeemit">.Eventizer.prototype.emit()</h3>

      <p>Trigger a custom event within an Eventizer instance. Provided context and arguments will be applied to the callback functions.</p>

      <p><strong>Syntax</strong></p>

      <p><code>e.emit( type [, args] [, context] )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>type</strong> &nbsp;—&nbsp; <em>string</em></li>
        <li><strong>args</strong> &nbsp;—&nbsp; <em>array</em></li>
        <li><strong>context</strong> &nbsp;—&nbsp; <em>anything</em></li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Eventizer</em></p>

      <p>Returns the instance that called the method.</p>

      <h3 id="eventizerprototypeemitasync">.Eventizer.prototype.emitAsync()</h3>

      <p>Same as <a href="#eventizerprototypeemit"><code>.Eventizer.prototype.emit()</code></a> with the exeception that the event will be emitted in the next turn of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">event loop</a>.</p>

      <p><strong>Syntax</strong></p>

      <p><code>e.emitAsync( type [, args] [, context] )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>type</strong> &nbsp;—&nbsp; <em>string</em></li>
        <li><strong>args</strong> &nbsp;—&nbsp; <em>array</em></li>
        <li><strong>context</strong> &nbsp;—&nbsp; <em>anything</em></li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Eventizer</em></p>

      <p>Returns the instance that called the method.</p>

      <h3 id="eventize">.eventize()</h3>

      <p>Creates and returns a new Eventizer instance.</p>

      <p><strong>Syntax</strong></p>

      <p><code>palikka.eventize( [obj] [, listeners] )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>obj</strong> &nbsp;—&nbsp; <em>object</em>
          <br>
          <ul>
            <li>Optional. If an object is provided a new eventizer instance is created and it’s methods are transported to the object.</li>
          </ul>
        </li>
        <li><strong>listeners</strong> &nbsp;—&nbsp; <em>object</em>
          <br>
          <ul>
            <li>Optional. If an object is provided the eventizer instance’s listeners are stored to the object.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Eventizer / object</em></p>

      <p>Returns a new Eventizer instance, or if the <strong>obj</strong> argument was provided returns the provided object.</p>

      <h2 id="deferreds">Deferreds</h2>

      <p>Palikka’s promises are called “deferreds”. Please, do note that the <code>.Deferred()</code> constructor is not a polyfill for native ES6 Promise, but it does follow the <a href="https://promisesaplus.com/">Promises/A+ v1.1</a> specification.</p>

      <p>By default the callback methods are called asynchronously in the beginning of the next <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">event loop</a> (as per Promises/A+ v1.1 specification). However, deferreds can be configured to work synchronously also: <code>palikka._config.asyncDeferreds = false</code>. Please note that turning synchronous behaviour on is against the Promises/A+ v1.1 specification, so do that only if you know what you are doing.</p>

      <h3 id="deferred">.Deferred()</h3>

      <p>A constructor function that creates a deferred instance, which is a spiced up version of the native ES6 Promise and <a href="https://promisesaplus.com/">Promises/A+ v1.1</a> compliant.</p>

      <p><strong>Syntax</strong></p>

      <p><code>palikka.Deferred( [executor] )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>executor</strong> &nbsp;—&nbsp; <em>function</em>
          <br>
          <ul>
            <li>Optional. The executor function has two arguments, <code>resolve</code> and <code>reject</code> functions, which can be used to resolve or reject the deferred.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Usage</strong></p>

      <pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> defer = <span class="hljs-keyword">new</span> palikka.Deferred(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(resolve, reject)</span> {</span>

  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    resolve(<span class="hljs-string">'done'</span>);
  }, <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">1000</span>));

  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    reject(<span class="hljs-string">'fail'</span>);
  }, <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">1000</span>));

});

defer
.onFulfilled(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(val)</span> {</span>
  console.log(val); <span class="hljs-comment">// "done"</span>
})
.onRejected(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(reason)</span> {</span>
  console.log(reason); <span class="hljs-comment">// "fail"</span>
})
.onSettled(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(val)</span> {</span>
  console.log(val); <span class="hljs-comment">// "done" or "fail"</span>
});</code></pre>

      <h3 id="deferredprototypestate">.Deferred.prototype.state()</h3>

      <p>Retrieve the current state of the deferred.</p>

      <p><strong>Syntax</strong></p>

      <p><code>deferred.state()</code></p>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>string</em></p>

      <p>Returns the state of the deferred instance: “pending”, “resolved” or “rejected”.</p>

      <p><strong>Usage</strong></p>

      <pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> palikka.Deferred();
<span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">new</span> palikka.Deferred();
console.log(d1.state()); <span class="hljs-comment">// "pending"</span>
console.log(d1.resolve().state()); <span class="hljs-comment">// "resolved"</span>
console.log(d2.reject().state()); <span class="hljs-comment">// "rejected"</span></code></pre>

      <h3 id="deferredprototyperesult">.Deferred.prototype.result()</h3>

      <p>Retrieve the result, the value with which the deferred instance was resolved or rejected, of the deferred instance.</p>

      <p><strong>Syntax</strong></p>

      <p><code>deferred.result()</code></p>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>anything</em></p>

      <p>Returns <code>undefined</code> if deferred is pending otherwise returns the value the deferred was resolved/rejected with.</p>

      <p><strong>Usage</strong></p>

      <pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> palikka.Deferred();
<span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">new</span> palikka.Deferred();
d1.resolve(<span class="hljs-number">1</span>).result(); <span class="hljs-comment">// 1</span>
d2.reject(<span class="hljs-number">2</span>).result(); <span class="hljs-comment">// 2</span></code></pre>

      <h3 id="deferredprototyperesolve">.Deferred.prototype.resolve()</h3>

      <p>Resolve the deferred instance.</p>

      <p><strong>Syntax</strong></p>

      <p><code>deferred.resolve( [result] )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>result</strong> &nbsp;—&nbsp; <em>anything</em>
          <br>
          <ul>
            <li>Optional. Defaults to <code>undefined</code>. A value that is passed on to the <a href="#deferredprototypeonfulfilled"><code>.onFulfilled()</code></a> and <a href="#deferredprototypeonsettled"><code>.onSettled()</code></a> callback methods. If the result is another deferred instance the current deferred instance will wait for the provided deferred to settle and then adopt it’s fate. Resolving a deferred with itself as the value is not allowed and will result in an error.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Deferred</em></p>

      <p>Returns the instance that called the method.</p>

      <h3 id="deferredprototypereject">.Deferred.prototype.reject()</h3>

      <p>Reject the deferred instance.</p>

      <p><strong>Syntax</strong></p>

      <p><code>deferred.reject( [reason] )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>reason</strong> &nbsp;—&nbsp; <em>anything</em>
          <br>
          <ul>
            <li>Optional. Defaults to <code>undefined</code>. A reason for rejection which is passed on to the <a href="#deferredprototypeonsettled"><code>.onRejected()</code></a> and <a href="#deferredprototypeonsettled"><code>.onSettled()</code></a> callback methods.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Deferred</em></p>

      <p>Returns the instance that called the method.</p>

      <h3 id="deferredprototypeonfulfilled">.Deferred.prototype.onFulfilled()</h3>

      <p>Add a callback that will be called when the deferred is resolved.</p>

      <p><strong>Syntax</strong></p>

      <p><code>deferred.onFulfilled( callback )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>callback</strong> &nbsp;—&nbsp; <em>function</em>
          <br>
          <ul>
            <li>Called when the deferred is resolved.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Deferred</em></p>

      <p>Returns the instance that called the method.</p>

      <h3 id="deferredprototypeonrejected">.Deferred.prototype.onRejected()</h3>

      <p>Add a callback that will be called when the deferred is rejected.</p>

      <p><strong>Syntax</strong></p>

      <p><code>deferred.onRejected( callback )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>callback</strong> &nbsp;—&nbsp; <em>function</em>
          <br>
          <ul>
            <li>Called when the deferred is rejected.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Deferred</em></p>

      <p>Returns the instance that called the method.</p>

      <h3 id="deferredprototypeonsettled">.Deferred.prototype.onSettled()</h3>

      <p>Add a callback that will be called when the deferred is either resolved or rejected.</p>

      <p><strong>Syntax</strong></p>

      <p><code>deferred.onSettled( callback )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>callback</strong> &nbsp;—&nbsp; <em>function</em>
          <br>
          <ul>
            <li>Called when the deferred is either resolved or rejected.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Deferred</em></p>

      <p>Returns the instance that called the method.</p>

      <h3 id="deferredprototypethen">.Deferred.prototype.then()</h3>

      <p>Chain deferreds. Returns a new deferred. An error thrown inside either of the callback arguments will be automatically silenced causing the returned deferred instance to be rejected. When one of the deferred instances within the chain of <code>.then()</code> methods is rejected all the following deferreds in the same chain will also be rejected until the error is “caught”. An error in the <code>.then()</code> chain can only be caught using the <strong>onRejected</strong> callback argument of a <code>.then()</code> method, e.g. <code>.then(null, onRejected)</code>. Note that <a href="#deferredprototypeonrejected"><code>.onRejected()</code></a> and <a href="#deferredprototypeonsettled"><code>.onSettled()</code></a> methods can only access the error, they can not catch the errors.</p>

      <p><strong>Syntax</strong></p>

      <p><code>deferred.then( [onFulfilled] [, onRejected] )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>onFulfilled</strong> &nbsp;—&nbsp; <em>function</em>
          <br>
          <ul>
            <li>Optional. Called when the deferred is resolved.</li>
          </ul>
        </li>
        <li><strong>onRejected</strong> &nbsp;—&nbsp; <em>function</em>
          <br>
          <ul>
            <li>Optional. Called when the deferred is rejected.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Deferred</em></p>

      <p>Returns a new deferred.</p>

      <h3 id="deferredprototypeand">.Deferred.prototype.and()</h3>

      <p>This method is basically just a wrapper for <a href="#when"><code>.when()</code></a> with the addition that the deferred instance which called the method is automatically included in the deferreds argument.</p>

      <p><code>deferred.and( deferreds [, resolveImmediately] [, rejectImmediately] )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>deferreds</strong> &nbsp;—&nbsp; <em>array</em>
          <br>
          <ul>
            <li>An <code>array</code> of deferreds, or any other values.</li>
          </ul>
        </li>
        <li><strong>resolveImmediately</strong> &nbsp;—&nbsp; <em>boolean</em>
          <br>
          <ul>
            <li>Optional. Defaults to <code>false</code>. If <code>true</code> the master deferred will be resolved immediately when the first deferred is resolved.</li>
          </ul>
        </li>
        <li><strong>rejectImmediately</strong> &nbsp;—&nbsp; <em>boolean</em>
          <br>
          <ul>
            <li>Optional. Defaults to <code>true</code>. If <code>true</code> the master deferred will be resolved immediately when the first deferred is rejected.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Deferred</em></p>

      <p>Returns a new deferred.</p>

      <h3 id="defer">.defer()</h3>

      <p>Create and return a new deferred instance. Shorthand for <a href="#deferred"><code>new  palikka.Deferred()</code></a>.</p>

      <p><strong>Syntax</strong></p>

      <p><code>palikka.defer( [executor] )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>executor</strong> &nbsp;—&nbsp; <em>function</em>
          <br>
          <ul>
            <li>Optional. The executor function has two arguments, <code>resolve</code> and <code>reject</code> functions, which can be used to resolve or reject the deferred.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Deferred</em></p>

      <h3 id="when">.when()</h3>

      <p>Returns a new master deferred that will be resolved when all provided deferreds are resolved. By default the master deferred will be rejected instantly when one of the provided deferreds is rejected. Any non-deferred object in <strong>deferreds</strong> argument will be turned into a new deferred instance and resolved immediately with the original object itself as the fulfillment value. This method is basically a combination of the native ES6 Promise’s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all()</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"><code>Promise.race()</code></a> methods.</p>

      <p><strong>Syntax</strong></p>

      <p><code>palikka.when( deferreds [, resolveImmediately] [, rejectImmediately] )</code></p>

      <p><strong>Parameters</strong></p>

      <ul>
        <li><strong>deferreds</strong> &nbsp;—&nbsp; <em>array</em>
          <br>
          <ul>
            <li>An <code>array</code> of deferreds, or any other objects.</li>
          </ul>
        </li>
        <li><strong>resolveImmediately</strong> &nbsp;—&nbsp; <em>boolean</em>
          <br>
          <ul>
            <li>Optional. Defaults to <code>false</code>. If <code>true</code> the master deferred will be resolved immediately when the first deferred is resolved.</li>
          </ul>
        </li>
        <li><strong>rejectImmediately</strong> &nbsp;—&nbsp; <em>boolean</em>
          <br>
          <ul>
            <li>Optional. Defaults to <code>true</code>. If <code>true</code> the master deferred will be resolved immediately when the first deferred is rejected.</li>
          </ul>
        </li>
      </ul>

      <p><strong>Returns</strong> &nbsp;—&nbsp; <em>Deferred</em></p>

      <h2 id="examples">Examples</h2>

      <h3 id="importing-third-party-libraries-as-modules">Importing third party libraries as modules</h3>

      <p>Not all JavaScript libraries are palikka modules, so we have tried to make importing third party libraries as easy as possible. Assuming all third party libraries populate a namespace in window object we can import (define) multiple modules at once. In the example below we assume that jQuery and Modernizr are loaded before executing the script.</p>

      <pre class="prettyprint"><code class="language-html hljs "><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"palikka.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"jquery.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"modernizr.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
palikka.define([<span class="hljs-string">'jQuery'</span>, <span class="hljs-string">'Modernizr'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-comment">// We assume that the id of the library matches it’s global namespace</span>
  <span class="hljs-keyword">return</span> window[<span class="hljs-keyword">this</span>.id];
});
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>

      <p>The problem with the above way of importing is that we have to just trust that the imported objects exist. Taking the import script a bit further we can add a little polling function that will import the object as soon as it exists. You might want to add some extra logic to the script, e.g. limiting the total amount of poll events, but this is a good starting point.</p>

      <pre class="prettyprint"><code class="language-html hljs "><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"palikka.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
palikka.define([<span class="hljs-string">'jQuery'</span>, <span class="hljs-string">'Modernizr'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> id = <span class="hljs-keyword">this</span>.id;
  <span class="hljs-keyword">return</span> palikka.defer(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(resolve)</span> {</span>
    <span class="hljs-keyword">var</span> poller = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">if</span> (id <span class="hljs-keyword">in</span> window) {
        clearInterval(poller);
        resolve(window[id]);
      }
    }, <span class="hljs-number">20</span>);
  });
});
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"jquery.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"modernizr.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>

    </div>

  </div>

</body>

</html>